function startTasksPolling(){if(tasksPollingTimer){clearInterval(tasksPollingTimer)}
tasksPollingTimer=setInterval(async()=>{try{const response=await fetch('/api/tasks')
const data=await response.json()
if(data.success){updateTasksList(data.tasks)
updateTasksStats(data.stats)}}catch(error){console.error('è½®è¯¢ä»»åŠ¡åˆ—è¡¨å¤±è´¥:',error)}},2000)
console.log('ä»»åŠ¡åˆ—è¡¨è½®è¯¢å·²å¯åŠ¨')}
function stopTasksPolling(){if(tasksPollingTimer){clearInterval(tasksPollingTimer)
tasksPollingTimer=null
console.log('ä»»åŠ¡åˆ—è¡¨è½®è¯¢å·²åœæ­¢')}}
let isManualSwitching=false
let manualSwitchingTimer=null
function updateTasksList(tasks){const oldTaskIds=currentTasks.map(t=>t.task_id)
const newTaskIds=tasks.map(t=>t.task_id)
const addedTasks=newTaskIds.filter(id=>!oldTaskIds.includes(id))
if(addedTasks.length>0){console.log(`âœ¨ æ£€æµ‹åˆ° ${addedTasks.length} ä¸ªæ–°ä»»åŠ¡`)
if(activeTaskId){showNewTaskVisualHint(addedTasks.length)}
tasks.filter(t=>addedTasks.includes(t.task_id)).forEach(task=>{if(task.status!=='completed'&&!taskCountdowns[task.task_id]){const timeout=task.remaining_time??task.auto_resubmit_timeout??290
startTaskCountdown(task.task_id,timeout,task.auto_resubmit_timeout||290)
console.log(`å·²ä¸ºæ–°ä»»åŠ¡å¯åŠ¨å€’è®¡æ—¶: ${task.task_id}, å‰©ä½™ ${timeout}s`)}})}
const removedTasks=oldTaskIds.filter(id=>!newTaskIds.includes(id))
if(removedTasks.length>0){console.log(`ğŸ—‘ï¸ æ£€æµ‹åˆ° ${removedTasks.length} ä¸ªå·²åˆ é™¤ä»»åŠ¡`)
removedTasks.forEach(taskId=>{if(taskCountdowns[taskId]){clearInterval(taskCountdowns[taskId].timer)
delete taskCountdowns[taskId]
console.log(`âœ… å·²æ¸…ç†ä»»åŠ¡ ${taskId} çš„å€’è®¡æ—¶`)}
if(taskTextareaContents[taskId]!==undefined){delete taskTextareaContents[taskId]}
if(taskOptionsStates[taskId]!==undefined){delete taskOptionsStates[taskId]}
if(taskImages[taskId]!==undefined){delete taskImages[taskId]}})}
currentTasks=tasks
const activeTask=tasks.find(t=>t.status==='active')
if(activeTask&&activeTask.task_id!==activeTaskId){const oldActiveTaskId=activeTaskId
activeTaskId=activeTask.task_id
console.log(`åŒæ­¥activeTaskId: ${oldActiveTaskId} -> ${activeTaskId}`)
updateCountdownRingColors(oldActiveTaskId,activeTaskId)}else if(!activeTaskId&&tasks.length>0){activeTaskId=tasks[0].task_id
console.log(`è‡ªåŠ¨è®¾ç½®ç¬¬ä¸€ä¸ªä»»åŠ¡ä¸ºactive: ${activeTaskId}`)}else if(tasks.length===0&&activeTaskId){console.log(`âœ… ä»»åŠ¡åˆ—è¡¨å·²æ¸…ç©ºï¼Œé‡ç½® activeTaskId: ${activeTaskId} -> null`)
activeTaskId=null}
renderTaskTabs()
if(isManualSwitching){return}
if(activeTask&&activeTask.task_id===activeTaskId){loadTaskDetails(activeTaskId)}}
function updateTasksStats(stats){return}
function renderTaskTabs(){const tabsContainer=document.getElementById('task-tabs')
const container=document.getElementById('task-tabs-container')
if(!container||!tabsContainer){console.warn('æ ‡ç­¾æ å®¹å™¨æœªæ‰¾åˆ°ï¼Œå¯èƒ½DOMè¿˜æœªåŠ è½½å®Œæˆï¼Œå°†åœ¨100msåé‡è¯•')
setTimeout(()=>{const retryContainer=document.getElementById('task-tabs-container')
const retryTabsContainer=document.getElementById('task-tabs')
if(retryContainer&&retryTabsContainer){console.log('âœ… é‡è¯•æˆåŠŸï¼Œå¼€å§‹æ¸²æŸ“æ ‡ç­¾æ ')
renderTaskTabs()}else{console.error('âŒ é‡è¯•å¤±è´¥ï¼Œæ ‡ç­¾æ å®¹å™¨ä»ç„¶æœªæ‰¾åˆ°')}},100)
return}
const incompleteTasks=currentTasks.filter(task=>task.status!=='completed')
if(incompleteTasks.length===0){container.classList.add('hidden')
return}
container.classList.remove('hidden')
const existingTabs=tabsContainer.querySelectorAll('.task-tab')
const existingTaskIds=Array.from(existingTabs).map(tab=>tab.dataset.taskId)
const currentTaskIds=currentTasks.map(t=>t.task_id)
const incompleteTaskIds=incompleteTasks.map(t=>t.task_id)
const needsRebuild=existingTaskIds.length!==incompleteTaskIds.length||existingTaskIds.some((id,i)=>id!==incompleteTaskIds[i])
if(needsRebuild){tabsContainer.innerHTML=''
incompleteTasks.forEach(task=>{const tab=createTaskTab(task)
tabsContainer.appendChild(tab)})}else{existingTabs.forEach(tab=>{const taskId=tab.dataset.taskId
const isActive=taskId===activeTaskId
tab.classList.toggle('active',isActive)})}}
function createTaskTab(task){const tab=document.createElement('div')
tab.className='task-tab'
if(task.status==='active'){tab.classList.add('active')}
tab.dataset.taskId=task.task_id
const textSpan=document.createElement('span')
textSpan.className='task-tab-text'
const taskParts=task.task_id.split('-')
const lastPart=taskParts[taskParts.length-1]
const prefixParts=taskParts.slice(0,-1).join('-')
let displayName
if(prefixParts.length>12){displayName=`${prefixParts.substring(0, 11)}... ${lastPart}`}else{displayName=`${prefixParts} ${lastPart}`}
textSpan.textContent=displayName
textSpan.title=task.task_id
tab.appendChild(textSpan)
if(task.status!=='completed'){const countdownRing=document.createElement('div')
countdownRing.className='countdown-ring'
countdownRing.id=`countdown-${task.task_id}`
let remaining,total
if(taskCountdowns[task.task_id]){remaining=taskCountdowns[task.task_id].remaining
total=taskCountdowns[task.task_id].timeout||290}else{remaining=task.remaining_time??task.auto_resubmit_timeout??290
total=task.auto_resubmit_timeout||290}
const radius=9
const circumference=2*Math.PI*radius
const progress=remaining/total
const offset=circumference*(1-progress)
const isActive=task.task_id===activeTaskId
const strokeColor=isActive?'rgba(255, 255, 255, 0.9)':'rgba(139, 92, 246, 0.9)'
countdownRing.innerHTML=`
      <svg width="22" height="22" viewBox="0 0 22 22">
        <circle
          cx="11" cy="11" r="${radius}"
          stroke="${strokeColor}"
          stroke-width="3"
          fill="none"
          stroke-dasharray="${circumference}"
          stroke-dashoffset="${offset}"
          stroke-linecap="round"
        />
      </svg>
      <span class="countdown-number">${remaining}</span>
    `
countdownRing.title=`å‰©ä½™${remaining}ç§’`
tab.appendChild(countdownRing)}
tab.onclick=()=>switchTask(task.task_id)
return tab}
async function switchTask(taskId){if(activeTaskId){const textarea=document.getElementById('feedback-text')
if(textarea){taskTextareaContents[activeTaskId]=textarea.value
console.log(`âœ… å·²ä¿å­˜ä»»åŠ¡ ${activeTaskId} çš„ textarea å†…å®¹`)}
const optionsContainer=document.getElementById('options-container')
if(optionsContainer){const checkboxes=optionsContainer.querySelectorAll('input[type="checkbox"]')
const optionsStates=[]
checkboxes.forEach((checkbox,index)=>{optionsStates[index]=checkbox.checked})
taskOptionsStates[activeTaskId]=optionsStates
console.log(`âœ… å·²ä¿å­˜ä»»åŠ¡ ${activeTaskId} çš„é€‰é¡¹å‹¾é€‰çŠ¶æ€`)}
taskImages[activeTaskId]=selectedImages.map(img=>({...img}))
console.log(`âœ… å·²ä¿å­˜ä»»åŠ¡ ${activeTaskId} çš„å›¾ç‰‡åˆ—è¡¨ (${selectedImages.length} å¼ )`)}
isManualSwitching=true
const oldActiveTaskId=activeTaskId
activeTaskId=taskId
renderTaskTabs()
updateCountdownRingColors(oldActiveTaskId,taskId)
try{const[activateResponse]=await Promise.all([fetch(`/api/tasks/${taskId}/activate`,{method:'POST'}),loadTaskDetails(taskId)])
const data=await activateResponse.json()
if(!data.success){console.error('åˆ‡æ¢ä»»åŠ¡å¤±è´¥:',data.error)}else{console.log(`å·²åˆ‡æ¢åˆ°ä»»åŠ¡: ${taskId}`)}}catch(error){console.error('åˆ‡æ¢ä»»åŠ¡å¤±è´¥:',error)}finally{if(manualSwitchingTimer){clearTimeout(manualSwitchingTimer)}
manualSwitchingTimer=setTimeout(()=>{isManualSwitching=false
manualSwitchingTimer=null
console.log('âœ… ä»»åŠ¡åˆ‡æ¢é”å®šå·²è§£é™¤ï¼Œå…è®¸è½®è¯¢æ¢å¤')},200)}}
function updateCountdownRingColors(oldActiveTaskId,newActiveTaskId){if(oldActiveTaskId){const oldRing=document.getElementById(`countdown-${oldActiveTaskId}`)
if(oldRing){const oldCircle=oldRing.querySelector('circle')
if(oldCircle){oldCircle.setAttribute('stroke','rgba(139, 92, 246, 0.9)')}}}
if(newActiveTaskId){const newRing=document.getElementById(`countdown-${newActiveTaskId}`)
if(newRing){const newCircle=newRing.querySelector('circle')
if(newCircle){newCircle.setAttribute('stroke','rgba(255, 255, 255, 0.9)')}}}}
async function loadTaskDetails(taskId){try{const response=await fetch(`/api/tasks/${taskId}`)
const data=await response.json()
if(taskId!==activeTaskId){console.log(`â­ï¸ è·³è¿‡è¿‡æœŸçš„ä»»åŠ¡è¯¦æƒ…: ${taskId}ï¼ˆå½“å‰æ´»åŠ¨: ${activeTaskId}ï¼‰`)
return}
if(data.success){const task=data.task
updateTaskIdDisplay(task.task_id)
updateDescriptionDisplay(task.prompt)
updateOptionsDisplay(task.predefined_options)
const textarea=document.getElementById('feedback-text')
if(textarea&&taskTextareaContents[taskId]!==undefined){textarea.value=taskTextareaContents[taskId]
console.log(`âœ… å·²æ¢å¤ä»»åŠ¡ ${taskId} çš„ textarea å†…å®¹`)}
if(taskImages[taskId]&&taskImages[taskId].length>0){selectedImages=taskImages[taskId].map(img=>({...img}))
const previewContainer=document.getElementById('image-previews')
if(previewContainer){previewContainer.innerHTML=''
selectedImages.forEach(imageItem=>{renderImagePreview(imageItem,false)})
updateImageCounter()
updateImagePreviewVisibility()}
console.log(`âœ… å·²æ¢å¤ä»»åŠ¡ ${taskId} çš„å›¾ç‰‡åˆ—è¡¨ (${selectedImages.length} å¼ )`)}
if(!taskCountdowns[task.task_id]){const remaining=task.remaining_time??task.auto_resubmit_timeout
const total=task.auto_resubmit_timeout
startTaskCountdown(task.task_id,remaining,total)
console.log(`é¦–æ¬¡å¯åŠ¨å€’è®¡æ—¶: ${taskId}, å‰©ä½™ ${remaining}s / æ€» ${total}s`)}else{console.log(`å€’è®¡æ—¶å·²å­˜åœ¨ï¼Œä¸é‡ç½®: ${taskId}`)}
console.log(`å·²åŠ è½½ä»»åŠ¡è¯¦æƒ…: ${taskId}`)}else{console.error('åŠ è½½ä»»åŠ¡è¯¦æƒ…å¤±è´¥:',data.error)}}catch(error){console.error('åŠ è½½ä»»åŠ¡è¯¦æƒ…å¤±è´¥:',error)}}
async function updateDescriptionDisplay(prompt){const descriptionElement=document.getElementById('description')
if(!descriptionElement)return
try{if(typeof renderMarkdownContent==='function'){renderMarkdownContent(descriptionElement,prompt,true)
console.log('âœ… ä½¿ç”¨ marked.js æ¸²æŸ“ Markdown')}else{if(typeof marked!=='undefined'){descriptionElement.innerHTML=marked.parse(prompt)
if(typeof Prism!=='undefined'){Prism.highlightAllUnder(descriptionElement)}
if(typeof processCodeBlocks==='function'){processCodeBlocks(descriptionElement)}
if(typeof window.MathJax!=='undefined'&&window.MathJax.typesetPromise){try{await window.MathJax.typesetPromise([descriptionElement])
console.log('âœ… MathJax æ¸²æŸ“å®Œæˆ')}catch(mathError){console.warn('MathJax æ¸²æŸ“å¤±è´¥:',mathError)}}}else{descriptionElement.textContent=prompt}}}catch(error){console.error('æ›´æ–°æè¿°å¤±è´¥:',error)
descriptionElement.textContent=prompt}}
function updateOptionsDisplay(options){const optionsContainer=document.getElementById('options-container')
if(!optionsContainer)return
let selectedStates=[]
if(activeTaskId&&taskOptionsStates[activeTaskId]){selectedStates=taskOptionsStates[activeTaskId]
console.log(`âœ… å·²æ¢å¤ä»»åŠ¡ ${activeTaskId} çš„é€‰é¡¹å‹¾é€‰çŠ¶æ€`)}else{const existingCheckboxes=optionsContainer.querySelectorAll('input[type="checkbox"]')
existingCheckboxes.forEach((checkbox,index)=>{selectedStates[index]=checkbox.checked})}
optionsContainer.innerHTML=''
if(options&&options.length>0){options.forEach((option,index)=>{const optionDiv=document.createElement('div')
optionDiv.className='option-item'
const checkbox=document.createElement('input')
checkbox.type='checkbox'
checkbox.id=`option-${index}`
checkbox.value=option
if(selectedStates[index]){checkbox.checked=true}
const label=document.createElement('label')
label.htmlFor=`option-${index}`
label.textContent=option
optionDiv.appendChild(checkbox)
optionDiv.appendChild(label)
optionsContainer.appendChild(optionDiv)})
optionsContainer.classList.remove('hidden')
optionsContainer.classList.add('visible')
const separator=document.getElementById('separator')
if(separator){separator.classList.remove('hidden')
separator.classList.add('visible')}}else{optionsContainer.classList.add('hidden')
optionsContainer.classList.remove('visible')}}
async function closeTask(taskId){if(!confirm(`ç¡®å®šè¦å…³é—­ä»»åŠ¡ ${taskId} å—ï¼Ÿ`)){return}
try{if(taskCountdowns[taskId]){clearInterval(taskCountdowns[taskId].timer)
delete taskCountdowns[taskId]}
if(taskTextareaContents[taskId]!==undefined){delete taskTextareaContents[taskId]
console.log(`âœ… [å…³é—­ä»»åŠ¡] å·²æ¸…é™¤ä»»åŠ¡ ${taskId} ä¿å­˜çš„ textarea å†…å®¹`)}
if(taskOptionsStates[taskId]!==undefined){delete taskOptionsStates[taskId]
console.log(`âœ… [å…³é—­ä»»åŠ¡] å·²æ¸…é™¤ä»»åŠ¡ ${taskId} ä¿å­˜çš„é€‰é¡¹å‹¾é€‰çŠ¶æ€`)}
if(taskImages[taskId]!==undefined){delete taskImages[taskId]
console.log(`âœ… [å…³é—­ä»»åŠ¡] å·²æ¸…é™¤ä»»åŠ¡ ${taskId} ä¿å­˜çš„å›¾ç‰‡åˆ—è¡¨`)}
currentTasks=currentTasks.filter(t=>t.task_id!==taskId)
renderTaskTabs()
if(activeTaskId===taskId&&currentTasks.length>0){switchTask(currentTasks[0].task_id)}
console.log(`å·²å…³é—­ä»»åŠ¡: ${taskId}`)}catch(error){console.error('å…³é—­ä»»åŠ¡å¤±è´¥:',error)}}
function startTaskCountdown(taskId,remaining,total=null){const timeout=total||remaining
if(taskCountdowns[taskId]&&taskCountdowns[taskId].timer){clearInterval(taskCountdowns[taskId].timer)}
taskCountdowns[taskId]={remaining:remaining,timeout:timeout,timer:null}
if(taskId===activeTaskId){updateCountdownDisplay(remaining)}
taskCountdowns[taskId].timer=setInterval(()=>{taskCountdowns[taskId].remaining--
const countdownRing=document.getElementById(`countdown-${taskId}`)
if(countdownRing){const remaining=taskCountdowns[taskId].remaining
const total=taskCountdowns[taskId].timeout||290
const progress=remaining/total
const radius=9
const circumference=2*Math.PI*radius
const offset=circumference*(1-progress)
const circle=countdownRing.querySelector('circle')
const numberSpan=countdownRing.querySelector('.countdown-number')
if(circle){circle.setAttribute('stroke-dashoffset',offset)}
if(numberSpan){numberSpan.textContent=remaining}
countdownRing.title=`å‰©ä½™${remaining}ç§’`}
if(taskId===activeTaskId){updateCountdownDisplay(taskCountdowns[taskId].remaining)}
if(taskCountdowns[taskId].remaining<=0){clearInterval(taskCountdowns[taskId].timer)
if(taskId===activeTaskId){autoSubmitTask(taskId)}else{if(!activeTaskId){console.log(`éæ¿€æ´»ä»»åŠ¡ ${taskId} è¶…æ—¶ï¼Œä¸”æ— æ´»åŠ¨ä»»åŠ¡ï¼Œè‡ªåŠ¨æäº¤`)
autoSubmitTask(taskId)}else{console.log(`ä»»åŠ¡ ${taskId} è¶…æ—¶ï¼Œä½†ç”¨æˆ·æ­£åœ¨å¤„ç†å…¶ä»–ä»»åŠ¡ ${activeTaskId}ï¼Œæš‚ä¸è‡ªåŠ¨æäº¤`)}}}},1000)
console.log(`å·²å¯åŠ¨ä»»åŠ¡å€’è®¡æ—¶: ${taskId}, å‰©ä½™ ${remaining}s / æ€» ${timeout}s`)}
function formatCountdown(seconds){if(seconds>60){return`${Math.floor(seconds / 60)}m`}
return`${seconds}s`}
async function autoSubmitTask(taskId){console.log(`ä»»åŠ¡ ${taskId} å€’è®¡æ—¶ç»“æŸï¼Œè‡ªåŠ¨æäº¤`)
const defaultMessage=typeof feedbackPrompts!=='undefined'&&feedbackPrompts.resubmit_prompt?feedbackPrompts.resubmit_prompt:'è¯·ç«‹å³è°ƒç”¨ interactive_feedback å·¥å…·'
await submitTaskFeedback(taskId,defaultMessage,[])}
async function submitTaskFeedback(taskId,feedbackText,selectedOptions){try{const formData=new FormData()
formData.append('feedback_text',feedbackText)
formData.append('selected_options',JSON.stringify(selectedOptions))
selectedImages.forEach((img,index)=>{if(img.file){formData.append(`image_${index}`,img.file)}})
const response=await fetch(`/api/tasks/${taskId}/submit`,{method:'POST',body:formData})
const data=await response.json()
if(data.success){console.log(`ä»»åŠ¡ ${taskId} æäº¤æˆåŠŸ`)
if(taskCountdowns[taskId]){clearInterval(taskCountdowns[taskId].timer)
delete taskCountdowns[taskId]}
if(taskTextareaContents[taskId]!==undefined){delete taskTextareaContents[taskId]
console.log(`âœ… å·²æ¸…é™¤ä»»åŠ¡ ${taskId} ä¿å­˜çš„ textarea å†…å®¹`)}
if(taskOptionsStates[taskId]!==undefined){delete taskOptionsStates[taskId]
console.log(`âœ… å·²æ¸…é™¤ä»»åŠ¡ ${taskId} ä¿å­˜çš„é€‰é¡¹å‹¾é€‰çŠ¶æ€`)}
if(taskImages[taskId]!==undefined){delete taskImages[taskId]
console.log(`âœ… å·²æ¸…é™¤ä»»åŠ¡ ${taskId} ä¿å­˜çš„å›¾ç‰‡åˆ—è¡¨`)}}else{console.error('æäº¤ä»»åŠ¡å¤±è´¥:',data.error)}}catch(error){console.error('æäº¤ä»»åŠ¡åé¦ˆå¤±è´¥:',error)}}
function showNewTaskVisualHint(count){const container=document.getElementById('task-tabs-container')
if(!container)return
const hint=document.createElement('div')
hint.id='new-task-hint'
hint.style.cssText=`
    position: fixed;
    top: 20px;
    right: 20px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    font-size: 14px;
    font-weight: 500;
    z-index: 10000;
    animation: slideInRight 0.3s ease-out, fadeOutUp 0.3s ease-in 2.7s forwards;
    pointer-events: none;
  `
hint.innerHTML=`âœ¨ ${count} ä¸ªæ–°ä»»åŠ¡å·²æ·»åŠ åˆ°æ ‡ç­¾æ `
document.body.appendChild(hint)
setTimeout(()=>{if(hint.parentNode){hint.parentNode.removeChild(hint)}},3000)
console.log(`æ˜¾ç¤ºæ–°ä»»åŠ¡è§†è§‰æç¤º: ${count} ä¸ªæ–°ä»»åŠ¡`)}
function showNewTaskNotification(count){showNewTaskVisualHint(count)
if(typeof notificationManager!=='undefined'){notificationManager.sendNotification('AI Intervention Agent',`æ”¶åˆ° ${count} ä¸ªæ–°ä»»åŠ¡`,{tag:'new-tasks',requireInteraction:false}).catch(error=>{console.warn('å‘é€æ–°ä»»åŠ¡é€šçŸ¥å¤±è´¥:',error)})}}
async function initMultiTaskSupport(){console.log('åˆå§‹åŒ–å¤šä»»åŠ¡æ”¯æŒ...')
await refreshTasksList()
startTasksPolling()
setInterval(()=>{if(!tasksPollingTimer){console.warn('âš ï¸ ä»»åŠ¡è½®è¯¢å·²åœæ­¢,è‡ªåŠ¨é‡æ–°å¯åŠ¨')
startTasksPolling()}},30000)
console.log('å¤šä»»åŠ¡æ”¯æŒåˆå§‹åŒ–å®Œæˆ (åŒ…å«è½®è¯¢å¥åº·æ£€æŸ¥)')}
async function refreshTasksList(){try{const response=await fetch('/api/tasks')
const data=await response.json()
if(data.success){updateTasksList(data.tasks)
updateTasksStats(data.stats)
console.log('ä»»åŠ¡åˆ—è¡¨å·²æ‰‹åŠ¨åˆ·æ–°')}}catch(error){console.error('æ‰‹åŠ¨åˆ·æ–°ä»»åŠ¡åˆ—è¡¨å¤±è´¥:',error)}}
if(typeof window!=='undefined'){window.multiTaskModule={startTasksPolling,stopTasksPolling,switchTask,closeTask,initMultiTaskSupport,refreshTasksList}}